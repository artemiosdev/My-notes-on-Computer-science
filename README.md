## Конспект по программированию и computer science, различные общие темы


**Первые 5 лекций, из курса [2021 Анализ данных на Python](https://www.youtube.com/playlist?list=PLRDzFCPr95fIgPrFFW-0nXT5YH6ZnjRM6) от старшего преподавателя кафедры информатики и вычислительной математики МФТИ [Тимофея Хирьянова](https://www.youtube.com/channel/UCQfwKTJdCmiA6cXAY0PNRJw)**

- Материалы курса находятся на [github](https://github.com/tkhirianov/pydatan)

- [Telegram-канал для общения по курсу](https://t.me/tkhirianov_data_analysis_with_py)

- https://www.python.org/

- https://pythonworld.ru/

### <a id="contents" />Оглавление

- [Лекция №1. SOLID-принципы. Введение в ООП на Python.](#lection1)
- [Лекция №2. Функциональное программирование на Python, итераторы, генераторы, редуктор, map(), лямбда-функции, цикл for, range, list comprehension.](#lection2)
- [Лекция №3. Параллельное программирование на Python. Многопоточность, асинхронность, Thread, Очередь/Queue, GIL.](#lection3)
- [Лекция №4. Скорость вычислений на Python.  Мультипроцессность/ multiprocessing, родительский процесс, дочерний процесс, очередь/queue.](#lection4)
- [Лекция №5. Командная строка GNU/Linux. Команды оболочки bash, файлы, написание скриптов с потоками ввода и вывода.](#lection5)

---
[К оглавлению](#contents)
###  <a id="lection1" /> Лекция №1. SOLID-принципы. Введение в ООП на Python

***В Python все объект!!!***. 

Три кита ООП из 80-х: инкапсуляция, полиморфизм, наследование.

### Парадигма ООП
- Данные структурируются в виде объектов, каждый из которых имеет определенный ***тип***, то есть принадлежит к какому-либо ***классу***.
- ***Классы*** – результат формализации решаемой задачи, выделения главных ее аспектов. ***Класс*** - это абстракция над объектом. А объекты это его конкретные экземпляры, представители.
- Внутри объекта ***инкапсулируется*** логика работы с относящейся к нему информацией. ***Инкапсуляция*** - это некая степень защиты от внешних воздействий, как в "капсулу помещается" для сохранности.
- Объекты в программе взаимодействуют друг с другом, обмениваются запросами и ответами.
- При этом объекты одного типа сходным образом отвечают на одни и те же запросы.
- Объекты могут организовываться в более сложные структуры, например, включать другие объекты или ***наследовать*** от одного или нескольких объектов. ***Наследование*** - подразумевает, что объект является как бы неким частным случаем другого объекта. 

### SOLID-принципы

Современная основа ООП. Как нам разбить программу на понятные людям сущности.  НО это не абсолютная истина, не стоит закосневать в них, и очень глубоко погружаться, везде есть исключения и компромисы.

- ***S*** Принцип единственной ответственности (single responsibility principle) Для каждого класса должно быть определено единственное назначение. У нас не должен возникать "божественный" объект который занимается всем. Каждый созданный объект должен решает одну конкретную задачу. Не стоит забывать о декомпозиции (разделение объектов) и выделении отдельных объектов.

- ***O*** Принцип открытости/закрытости (open–closed principle) «программные сущности ... должны быть открыты для расширения, но закрыты для модификации». Обратная совместимость, аналогия с машиной, можем улучшать от модели к модели, НО не меняя публичные интерфейсы (педали, руль и тп), т.е тот кто водил старую машину, сможет ездить и на новой. Скрытые штуки "под капотом" менять и модифицировать можно т.е это относится к реализации, НО это если сам интерфейс не меняется, т.е остается таким каким он был задуман и спроектирован изначально.

- ***L*** Принцип подстановки Лисков (Liskov substitution principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы». Данный принцип про "правильное наследование", так как порой высокая иерархия наследования может быть вредна. У каждого объекта есть тип, т.е класс, и сами классы выстраиваются в иерархию классов и могут наследовать функциональность своих предков. Аналогия: сын электрика должен выполнять всю ту же работу что и сам отец по функционалу, и не требовать взятку, т.е работать за ту же плату. Подтип (сын электрика) заданного типа, должен делать всю старую функциональность как и сам старый тип (электрик), пользователь не должен замечать изменений. 

- ***I*** Принцип разделения интерфейса (interface segregation principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения». Швейцарский нож - это зло. Здесь подразумевается универсальный метод который делает очень многое. Интерфейс - это способ (чаще всего это метод) повзаимодействовать с какой-либо программной сущностью. Лучше сделать несколько узкоспециализированных интерфейсов, чем один общего назначения. НО есть и другая сторона, если включить голову, то можно где-то и нарушить данный принцип. Пример: отдельный объект кофемолка, отдельный объект турка на огне., можно объединить их и получится единая сущность -> кофеварка, которая принимает кофейные зерна на вход, мелит их, и сразу же в себе самой, варит кофе.

- ***D*** Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». Пример с машинкой, если мы хотим повесить зависимость на человека, то он должен зависеть не от конкретного устройства автомобиля, а нужно выработать некий абстрактный интерфейс и зависеть от него. Сравнение электромобиля и обычного авто, интерфейс одинаковый, но реализация под капотом разная, но при взаимодействии пользователя с машиной, реализация не должна его волновать.  В Python для этого используются ***абстрактные классы***.

Во многом это и есть владение техникой ООП, а именно познать сущность, выделить сущность, дать имя сущности, по сути абстрагироваться от конкретики

***Объектно-ориентированное программирование (ООП)*** — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.

***Класс***— тип, описывающий устройство объектов. 

***Объект*** — это экземпляр класса.

Простейший пример класса:
```python
class C: 
    pass

имя_объекта = имя_класса()
# когда мы как бы вызываем класс, то создается его экземпляр
```

```python
class Rectangle: 
    #статический атрибут
    default_color = "green"
    
    #конструктор
    def __init__(self, width, height):
        #динамические атрибуты
        self.width = width 
        self.height = height
```

Метод `__init__` называется конструктором. Собственно, конструктор зовется при выполнении конструкции вида `ИмяКласса()`. `__name__` это специальные ***магические методы*** из справочника языка

```python
__init__(self, ...) #  инициализатор класса.

__del__ # деструктор объекта.
def __del__(self): 
	self.file.close() 
	del self.file
```

***Абстрактным*** называется класс, который содержит один и более абстрактных методов. Абстрактным называется объявленный, но не реализованный ***метод***. Т.е он не реализован, у этого класса не бывает экземпляров. Данные классы нужны нам при проектировании 

```python
# для использования необходима библиотека
from abc import ABC, abstractmethod

class ChessPiece(ABC):
    # общий метод, который будут использовать все наследники этого класса
    def draw(self):
        print("Drew a chess piece")
        
    # абстрактный метод, который будет необходимо переопределять для каждого подкласса
    @abstractmethod 
    def passmove(self):
        pass
```

***Декомпозиция программы на модули. Менеджер контеста.***

Функции модулей:
- Повторное использование кода: такой код может быть загружен много раз во многих местах.

- Управление адресным пространством: модуль — это высокоуровневая организация программ, это пакет имен, который избавляет вас от конфликтов. Каждый объект «проживает» свой цикл внутри своего модуля, поэтому модуль — это средство для группировки системных компонентов.

- Глобализация сервисов и данных: для реализации объекта, который используется во многих местах, достаточно написать один модуль, который будет импортирован.

1. Модуль с именем `my_module` можно импортировать как `import my_module`. После этого мы получаем доступ ко всем функциям определённым в модуле: 
```python
my_module.func1()
my_module.func2()
f1 = my_module.func1
```

2. 
```python
# берем отдельный нужный нам функционал
from my_module import func1, func2 
func1()
```

3. 
```python
# берем все, высыпаем всю коробку с инструментами
from my_module import * 
func1()
```

Библиотек в языке огромное множество вот некоторые: [The Python Standard Library](https://docs.python.org/3/library/index.html)

---
[К оглавлению](#contents)
###  <a id="lection2" /> Лекция №2. Функциональное программирование на Python, итераторы, генераторы, редуктор, map(), лямбда-функции, цикл for, range, list comprehension

Разделение языков программирования: 
- императивные. Блок-схемы, ассемблер (чисто импераативный), машинные коды, в которых четко и строго определена последовательность действий. Пишем как император, т.е повелеваем и управляем. Команды, приказы - это стиль данного языка. Тьюринг полный язык (т.е на данном языке можно вычислить все что угодно)

- функциональные. Вычисляем функциями, здесь нам не нужно описывать и задавать строгую последовательность действий. В чистых функциональных языках НЕТ ПЕРЕМЕННЫХ, нет присваивания и изменяемых структур, циклов, нет массивов и списков, ЕСТЬ функции и константы. 
Python не является чисто функциональным языком. В чистом функциональном языке, циклы заменяются рекурсией. Тьюринг полный язык (т.е на данном языке можно вычислить все что угодно). Функции можно производить в процессе производства.

- логические (Prolog)

***Алгоритм*** - это вычислимая функция (так как можно вычислить на машине Тьюринга). Алгоритм - это последовательность команд означающих действия, на формальном языке исполнителя, идущая к цели за конечное время.

Рассматриваем функциональные:

```python
def foo(x):
    return x + 1
foo(1) # 2
y = foo(1)

def progression(start, stop, step):
    if start >= stop:
        return
    else:
        print(start)
        progression(start + step, stop, step)
        
progression(0, 10, 1)
```
Есть чистые функции - подразумевают вычисления. Можно закэшировать, т.е запомнить значение ее вычисления.. . А есть нечистые функции - подразумевают действия.

### Итерируемые объекты-последовательности

***Генератор*** - повышает размерность последовательности

***Редуктор*** - понижает размерность последовательности. Сокращение. 

<img alt="image" src="images/Итерируемые объекты-последовательности.jpg"/>

Пример использования функционального стиля, здесь функция имеет побочный эффект (print) для наглядности процесса. ***Итерируемый объект*** - это тот который можно "доить", здесь мы видим отложенные вычисления.

```python
def f(x):
    print('calculating {x}*10')
    return x * 10
    
A = (1, 2, 3, 4, 5)
B = (f(x) for x in A)
type(B) # <class 'generator'>
for y in B:
    print(y)
```

```bash
calculating {x}*10
10
calculating {x}*10
20
calculating {x}*10
30
calculating {x}*10
40
calculating {x}*10
50
```

В функциональном программировании вычисления выполняются путем объединения функций, которые принимают аргументы и возвращают конкретное значение (или значения). Эти функции не изменяют свои входные аргументы и не изменяют состояние программы. Они просто предоставляют результат данного вычисления. Такие функции обычно называются чистыми функциями (pure functions).

***[Использование функции map в Python](https://www.digitalocean.com/community/tutorials/how-to-use-the-python-map-function-ru)***

`map()` — это встроенная функция, которая позволяет обрабатывать и преобразовывать все элементы в итерируемом объекте без использования явного цикла `for`, методом, широко известным как сопоставление (mapping). `map()` полезен, когда вам нужно применить функцию преобразования к каждому элементу в коллекции или в массиве и преобразовать их в новый массив.

`map()` — один из инструментов, поддерживающих стиль функционального программирования в Python.

Встроенная в Python функция `map()` используется для применения функции к каждому элементу итерируемого объекта (например, списка или словаря) и возврата нового итератора для получения результатов. Функция `map()` возвращает объект `map` (итератор), который мы можем использовать в других частях нашей программы. Также мы можем передать объект `map` в функцию `list()` или другой тип последовательности для создания итерируемого объекта.

Функция `map()` имеет следующий синтаксис:

```python
map(function, iterable, [iterable 2, iterable 3, ...])
```

Вместо использования цикла `for` функция `map()` дает возможность применить функцию к каждому элементу итерируемого объекта. Это повышает производительность, поскольку функция применяется только к одному элементу за раз без создания копий элементов в другом итерируемом объекте. Это особенно полезно при обработке больших наборов данных. Также `map()` может принимать несколько итерируемых объектов в качестве аргументов функции, отправляя в функцию по одному элементу каждого итерируемого объекта за раз.

Мы можем передать объект функцию как параметра. Можно передавать последовательность функций, и в результате может появиться даже новая функция. Пока функция не запущена, ее можно передать в качестве параметра и тп. 

```python
def double_performer(f, x):
    return f(f(x))

def f(x): 
    return x*10
print(double_performer(f, 5)) # 500
```

Функции как аргументы:

```python
def double_performer(f, x):
    return f(f(x))

def f1(x): 
    return x*10

def f2(x): 
    return x * x
    
def f3(x): 
    return -x

for f in f1, f2, f3:
    y = double_performer(f, 5)
    print(y)
```

```bash
500
625
5
```

Пример с `map()`

```python
def f1(x): 
    return x*10

A = (1, 2, 3, 4, 5)
C = map(f1, A)
type(C) # <class 'map'>
print(C) # <map object at 0x7ff5ab4c6c18>
for y in C:
    print(y)
```

`range` - это не список, это некий объект, арифметическая прогрессия, и он вычисляет число ровно в тот момент когда мы просит его это сделать (всю последовательность он не хранит, т.к память бы не выдержала)

```python
A = range(1000000000000)
A[50000000] # 50000000
A[128976184345] # 128976184345
A = range(10)
B = (x for x in A if x % 2 == 0)
type(B) # <class 'generator'>

print(B) # <generator object <genexpr> at 0x7ff5ab4d2480>

print(*B) # 0 2 4 6 8

print(*(x * x for x in A if x % 2 == 1)) # 1 9 25 49 81
```

***Безымянные функции - это лямбда***. [о lambda-функциях здесь,](https://pythonru.com/osnovy/vse-chto-nuzhno-znat-o-lambda-funkcijah-v-python) и [здесь](https://habr.com/ru/company/piter/blog/674234/)

Лямбда-функции в Python являются анонимными. Это означает, что функция безымянна. Как известно, ключевое слов `def` используется в Python для определения обычной функции. В свою очередь, ключевое слово `lambda` используется для определения анонимной функции.

Обычно они нужны тогда, когда в языке возникает возможность передавать функцию в качестве параметра или возвращать в качестве значения.

```python
def defined_cube(y):
    return y*y*y

lambda_cube = lambda y: y*y*y

print(defined_cube(2)) # 8 
print(lambda_cube(2)) # 8 
```

Мы заменяем `def defined_cube(y): return y*y*y` на `lambda y: y*y*y` . После выполнения функция лямбда будет забыта и исчезнет. 

```python
A = range(10)
print(*map(lambda x: x*10 + x, A))
```

```bash
0 11 22 33 44 55 66 77 88 99
```

Язык мультипарадигменный. Парадигма - это подход к программированию. Например чистый Си не поддерживает парадигму функционального программирования, так как он чисто императивный.

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection3" /> Лекция №3. Параллельное программирование на Python. Многопоточность, асинхронность, Thread, Очередь/Queue, GIL


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection4" /> Лекция №4. Скорость вычислений на Python.  Мультипроцессность/ multiprocessing, родительский процесс, дочерний процесс, очередь/queue. 


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection5" /> Лекция №5. Командная строка GNU/Linux. Команды оболочки bash, файлы, написание скриптов с потоками ввода и вывода.


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>