## Конспект по программированию и computer science, различные общие темы


**Первые 5 лекций, из курса [2021 Анализ данных на Python](https://www.youtube.com/playlist?list=PLRDzFCPr95fIgPrFFW-0nXT5YH6ZnjRM6) от старшего преподавателя кафедры информатики и вычислительной математики МФТИ [Тимофея Хирьянова](https://www.youtube.com/channel/UCQfwKTJdCmiA6cXAY0PNRJw)**

- Материалы курса находятся на [github](https://github.com/tkhirianov/pydatan)

- [Telegram-канал для общения по курсу](https://t.me/tkhirianov_data_analysis_with_py)

- https://www.python.org/

- https://pythonworld.ru/

### <a id="contents" />Оглавление

- [Лекция №1. SOLID-принципы. Введение в ООП на Python.](#lection1)
- [Лекция №2. Функциональное программирование на Python, итераторы, генераторы, редуктор, map(), лямбда-функции, цикл for, range, list comprehension.](#lection2)
- [Лекция №3. Параллельное программирование на Python. Многопоточность, асинхронность, Thread, Очередь/Queue, GIL.](#lection3)
- [Лекция №4. Скорость вычислений на Python.  Мультипроцессность/ multiprocessing, родительский процесс, дочерний процесс, очередь/queue.](#lection4)
- [Лекция №5. Командная строка GNU/Linux. Команды оболочки bash, файлы, написание скриптов с потоками ввода и вывода.](#lection5)

---
[К оглавлению](#contents)
###  <a id="lection1" /> Лекция №1. SOLID-принципы. Введение в ООП на Python

***В Python все объект!!!***

Три кита ООП из 80-х: инкапсуляция, полиморфизм, наследование.

### Парадигма ООП
- Данные структурируются в виде объектов, каждый из которых имеет определенный ***тип***, то есть принадлежит к какому-либо ***классу***.
- ***Классы*** – результат формализации решаемой задачи, выделения главных ее аспектов. ***Класс*** - это абстракция над объектом. А объекты это его конкретные экземпляры, представители.
- Внутри объекта ***инкапсулируется*** логика работы с относящейся к нему информацией. ***Инкапсуляция*** - это некая степень защиты от внешних воздействий, как в "капсулу помещается" для сохранности.
- Объекты в программе взаимодействуют друг с другом, обмениваются запросами и ответами.
- При этом объекты одного типа сходным образом отвечают на одни и те же запросы.
- Объекты могут организовываться в более сложные структуры, например, включать другие объекты или ***наследовать*** от одного или нескольких объектов. ***Наследование*** - подразумевает, что объект является как бы неким частным случаем другого объекта. 

### SOLID-принципы

Современная основа ООП. Как нам разбить программу на понятные людям сущности.  НО это не абсолютная истина, не стоит закосневать в них, и очень глубоко погружаться, везде есть исключения и компромисы.

- ***S*** Принцип единственной ответственности (single responsibility principle) Для каждого класса должно быть определено единственное назначение. У нас не должен возникать "божественный" объект который занимается всем. Каждый созданный объект должен решает одну конкретную задачу. Не стоит забывать о декомпозиции (разделение объектов) и выделении отдельных объектов.

- ***O*** Принцип открытости/закрытости (open–closed principle) «программные сущности ... должны быть открыты для расширения, но закрыты для модификации». Обратная совместимость, аналогия с машиной, можем улучшать от модели к модели, НО не меняя публичные интерфейсы (педали, руль и тп), т.е тот кто водил старую машину, сможет ездить и на новой. Скрытые штуки "под капотом" менять и модифицировать можно т.е это относится к реализации, НО это если сам интерфейс не меняется, т.е остается таким каким он был задуман и спроектирован изначально.

- ***L*** Принцип подстановки Лисков (Liskov substitution principle) «объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы». Данный принцип про "правильное наследование", так как порой высокая иерархия наследования может быть вредна. У каждого объекта есть тип, т.е класс, и сами классы выстраиваются в иерархию классов и могут наследовать функциональность своих предков. Аналогия: сын электрика должен выполнять всю ту же работу что и сам отец по функционалу, и не требовать взятку, т.е работать за ту же плату. Подтип (сын электрика) заданного типа, должен делать всю старую функциональность как и сам старый тип (электрик), пользователь не должен замечать изменений. 

- ***I*** Принцип разделения интерфейса (interface segregation principle) «много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения». Швейцарский нож - это зло. Здесь подразумевается универсальный метод который делает очень многое. Интерфейс - это способ (чаще всего это метод) повзаимодействовать с какой-либо программной сущностью. Лучше сделать несколько узкоспециализированных интерфейсов, чем один общего назначения. НО есть и другая сторона, если включить голову, то можно где-то и нарушить данный принцип. Пример: отдельный объект кофемолка, отдельный объект турка на огне., можно объединить их и получится единая сущность -> кофеварка, которая принимает кофейные зерна на вход, мелит их, и сразу же в себе самой, варит кофе.

- ***D*** Принцип инверсии зависимостей (dependency inversion principle) «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». Пример с машинкой, если мы хотим повесить зависимость на человека, то он должен зависеть не от конкретного устройства автомобиля, а нужно выработать некий абстрактный интерфейс и зависеть от него. Сравнение электромобиля и обычного авто, интерфейс одинаковый, но реализация под капотом разная, но при взаимодействии пользователя с машиной, реализация не должна его волновать.  В Python для этого используются ***абстрактные классы***.

Во многом это и есть владение техникой ООП, а именно познать сущность, выделить сущность, дать имя сущности, по сути абстрагироваться от конкретики

***Объектно-ориентированное программирование (ООП)*** — парадигма программирования, в которой основными концепциями являются понятия объектов и классов.

***Класс***— тип, описывающий устройство объектов. 

***Объект*** — это экземпляр класса.

Простейший пример класса:
```python
class C: 
    pass

имя_объекта = имя_класса()
# когда мы как бы вызываем класс, то создается его экземпляр
```

```python
class Rectangle: 
    #статический атрибут
    default_color = "green"
    
    #конструктор
    def __init__(self, width, height):
        #динамические атрибуты
        self.width = width 
        self.height = height
```

Метод `__init__` называется конструктором. Собственно, конструктор зовется при выполнении конструкции вида `ИмяКласса()`. `__name__` это специальные ***магические методы*** из справочника языка

```python
__init__(self, ...) #  инициализатор класса.

__del__ # деструктор объекта.
def __del__(self): 
	self.file.close() 
	del self.file
```

***Абстрактным*** называется класс, который содержит один и более абстрактных методов. Абстрактным называется объявленный, но не реализованный ***метод***. Т.е он не реализован, у этого класса не бывает экземпляров. Данные классы нужны нам при проектировании 

```python
# для использования необходима библиотека
from abc import ABC, abstractmethod

class ChessPiece(ABC):
    # общий метод, который будут использовать все наследники этого класса
    def draw(self):
        print("Drew a chess piece")
        
    # абстрактный метод, который будет необходимо переопределять для каждого подкласса
    @abstractmethod 
    def passmove(self):
        pass
```

***Декомпозиция программы на модули. Менеджер контеста.***

Функции модулей:
- Повторное использование кода: такой код может быть загружен много раз во многих местах.

- Управление адресным пространством: модуль — это высокоуровневая организация программ, это пакет имен, который избавляет вас от конфликтов. Каждый объект «проживает» свой цикл внутри своего модуля, поэтому модуль — это средство для группировки системных компонентов.

- Глобализация сервисов и данных: для реализации объекта, который используется во многих местах, достаточно написать один модуль, который будет импортирован.

1. Модуль с именем `my_module` можно импортировать как `import my_module`. После этого мы получаем доступ ко всем функциям определённым в модуле: 
```python
my_module.func1()
my_module.func2()
f1 = my_module.func1
```

2. 
```python
# берем отдельный нужный нам функционал
from my_module import func1, func2 
func1()
```

3. 
```python
# берем все, высыпаем всю коробку с инструментами
from my_module import * 
func1()
```

Библиотек в языке огромное множество вот некоторые: [The Python Standard Library](https://docs.python.org/3/library/index.html)

---
[К оглавлению](#contents)
###  <a id="lection2" /> Лекция №2. Функциональное программирование на Python, итераторы, генераторы, редуктор, map(), лямбда-функции, цикл for, range, list comprehension

Разделение языков программирования: 
- императивные. Блок-схемы, ассемблер (чисто импераативный), машинные коды, в которых четко и строго определена последовательность действий. Пишем как император, т.е повелеваем и управляем. Команды, приказы - это стиль данного языка. Тьюринг полный язык (т.е на данном языке можно вычислить все что угодно)

- функциональные. Вычисляем функциями, здесь нам не нужно описывать и задавать строгую последовательность действий. В чистых функциональных языках НЕТ ПЕРЕМЕННЫХ, нет присваивания и изменяемых структур, циклов, нет массивов и списков, ЕСТЬ функции и константы. 
Python не является чисто функциональным языком. В чистом функциональном языке, циклы заменяются рекурсией. Тьюринг полный язык (т.е на данном языке можно вычислить все что угодно)

- логические (Prolog)

***Алгоритм*** - это вычислимая функция (так как можно вычислить на машине Тьюринга). Алгоритм - это последовательность команд означающих действия, на формальном языке исполнителя, идущая к цели за конечное время.

Рассматриваем функциональные:

```python
def foo(x):
    return x + 1
foo(1) # 2
y = foo(1)

def progression(start, stop, step):
    if start >= stop:
        return
    else:
        print(start)
        progression(start + step, stop, step)
        
progression(0, 10, 1)
```
Есть чистые функции - подразумевают вычисления. Можно закэшировать, т.е запомнить значение ее вычисления.. . А есть нечистые функции - подразумевают действия.

***Генератор*** - повышает размерность последовательности

***Редуктор*** - понижает размерность последовательности

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection3" /> Лекция №3. Параллельное программирование на Python. Многопоточность, асинхронность, Thread, Очередь/Queue, GIL


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection4" /> Лекция №4. Скорость вычислений на Python.  Мультипроцессность/ multiprocessing, родительский процесс, дочерний процесс, очередь/queue. 


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

---
[К оглавлению](#contents)
###  <a id="lection5" /> Лекция №5. Командная строка GNU/Linux. Команды оболочки bash, файлы, написание скриптов с потоками ввода и вывода.


```python

```

```python

```

```python

```

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>

<img alt="image" src="images/name.jpg"/>